{"version":3,"file":"contentScript.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://react-extension/./src/components/topPage.ts","webpack://react-extension/./src/contentScript/blockedCountUpdateManager.ts","webpack://react-extension/./src/contentScript/contentScript.tsx","webpack://react-extension/./src/contentScript/googleImages.ts","webpack://react-extension/./src/contentScript/googleNews.ts","webpack://react-extension/./src/contentScript/googleRegular.ts","webpack://react-extension/./src/contentScript/googleVideos.ts","webpack://react-extension/./src/helper/urlHelpers.ts","webpack://react-extension/webpack/bootstrap","webpack://react-extension/webpack/runtime/define property getters","webpack://react-extension/webpack/runtime/hasOwnProperty shorthand","webpack://react-extension/webpack/runtime/make namespace object","webpack://react-extension/./src/contentScript/index.tsx"],"sourcesContent":["const styles = `\r\n  .extension-button:hover { opacity: 0.4 !important; }\r\n  .extension-button:active { transform: scale(0.99) !important; }\r\n .blocked-count-overlay {\r\n  position: absolute;\r\n  background-color: #8e8280;\r\n  color: white;\r\n  padding-right: 2px;\r\n  padding-left: 2px;\r\n  font-size: 12px;\r\n  border-radius: 8px;\r\n  font-weight: bold;\r\n  min-width: 26px;\r\n  max-width: 60px;\r\n  height: 15px;\r\n  top: 1px;\r\n  right: -8px;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);\r\n  user-select: none;\r\n}\r\n#extension-button-search-bar{\r\n  position: relative;\r\n  user-select: none;\r\n}\r\n.logo-image{\r\n  width: 22px;\r\n  height: 22px;\r\n}\r\n`;\nexport function addTopOfPage(getResultsAreHidden, setResultsAreHidden, blockedCount, isExtensionOn) {\n    let searchFormContainer = document.querySelector(\".fM33ce\");\n    let container = document.createElement(\"div\");\n    // if for whatever reason the searchFormContainer can not be found use the more secure appbar (this is under the search bar)\n    if (!searchFormContainer) {\n        searchFormContainer = document.querySelector(\"#appbar\");\n        container.style.marginBottom = \"5px\";\n        if (!searchFormContainer) {\n            return;\n        }\n    }\n    container.id = \"extension-button-search-bar\";\n    container.title = getTitle(blockedCount, getResultsAreHidden());\n    container.className = \"XDyW0e\";\n    const img = document.createElement(\"img\");\n    img.src = chrome.runtime.getURL(\"logoApp.png\");\n    img.className = \"logo-image\";\n    const blockedOverlay = document.createElement(\"div\");\n    blockedOverlay.className = \"blocked-count-overlay\";\n    blockedOverlay.textContent = blockedCount.toString();\n    container = isExtensionOn ? getExtensionOnElement(container) : getExtensionOffElement(container);\n    container.appendChild(img);\n    container.appendChild(blockedOverlay);\n    // Insert the container after the form\n    const form = searchFormContainer.querySelector(\".dRYYxd\");\n    if (form) {\n        form.insertAdjacentElement(\"afterend\", container);\n    }\n    else {\n        searchFormContainer.appendChild(container);\n    }\n    function getExtensionOnElement(container) {\n        container.addEventListener(\"click\", () => {\n            setResultsAreHidden(!getResultsAreHidden());\n            container.title = getTitle(blockedCount, getResultsAreHidden());\n        });\n        return container;\n    }\n    addStylesToHead();\n    function addStylesToHead() {\n        const styleElement = document.createElement(\"style\");\n        styleElement.textContent = styles;\n        document.head.appendChild(styleElement);\n    }\n    function getExtensionOffElement(container) {\n        container.title = \"Search Sanitizer is currently turned off. Click to turn back on\";\n        container.style.opacity = \"0.4\";\n        container.addEventListener(\"click\", () => {\n            chrome.storage.local.set({ extensionOnOff: true }, () => {\n                window.location.reload();\n            });\n        });\n        return container;\n    }\n}\nfunction getTitle(blockedCount, resultsHidden) {\n    if (blockedCount < 1) {\n        return `${blockedCount} hidden search results`;\n    }\n    else {\n        return `${blockedCount} hidden search results. Click to ${!resultsHidden ? \"show\" : \"hide\"} them again`;\n    }\n}\nexport function updateBlockedCount(blockedCount) {\n    const container = document.querySelector(\"#extension-button-search-bar\");\n    if (container) {\n        container.title = getTitle(blockedCount, false);\n    }\n    const overlayContainer = document.querySelector(\".blocked-count-overlay\");\n    if (overlayContainer) {\n        overlayContainer.textContent = blockedCount.toString();\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport class BlockedCountUpdateManager {\n    constructor(blockedUrlsDict, lifetimeBlocks, updateCallback) {\n        this.blockedUrlsDict = blockedUrlsDict;\n        this.updateCallback = updateCallback;\n        this.countUpdates = {};\n        this.lifetimeBlocks = { w: 0, i: 0, v: 0, n: 0 };\n        this.lifetimeBlocks = lifetimeBlocks;\n        this.debouncedBatchUpdate = this.debounce(() => this.batchUpdateCounts(), 1000);\n        window.addEventListener(\"beforeunload\", () => this.batchUpdateCounts());\n    }\n    incrementCount(userPattern, searchType) {\n        if (!this.countUpdates[userPattern]) {\n            this.countUpdates[userPattern] = { w: 0, i: 0, v: 0, n: 0 };\n        }\n        this.countUpdates[userPattern][searchType]++;\n        this.debouncedBatchUpdate();\n    }\n    batchUpdateCounts() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (Object.keys(this.countUpdates).length === 0)\n                return;\n            const updatedBlockedUrlData = Object.assign({}, this.blockedUrlsDict.blockedUrlData);\n            const updatedLifeTimeBlocks = Object.assign({}, this.lifetimeBlocks);\n            for (const [url, counts] of Object.entries(this.countUpdates)) {\n                if (!updatedBlockedUrlData[url]) {\n                    updatedBlockedUrlData[url] = { w: 0, i: 0, v: 0, n: 0 };\n                }\n                for (const type of [\"w\", \"i\", \"v\", \"n\"]) {\n                    updatedBlockedUrlData[url][type] += counts[type];\n                    updatedLifeTimeBlocks[type] += counts[type];\n                }\n            }\n            try {\n                // Update both blockedUrlData and lifetimeTotalBlocks in storage\n                yield chrome.storage.local.set({\n                    blockedUrlData: updatedBlockedUrlData,\n                    lifetimeTotalBlocks: updatedLifeTimeBlocks,\n                });\n                this.updateCallback(updatedBlockedUrlData);\n                // Clear the accumulated updates\n                this.countUpdates = {};\n            }\n            catch (error) {\n                console.error(\"Failed to update blocked URL data:\", error);\n            }\n        });\n    }\n    debounce(func, wait) {\n        let timeout;\n        return (...args) => {\n            clearTimeout(timeout);\n            timeout = setTimeout(() => func(...args), wait);\n        };\n    }\n}\n","import { addTopOfPage, updateBlockedCount } from \"../components/topPage\";\nimport { isPatternUrl, isPatternWildcard } from \"../helper/urlHelpers\";\nimport { BlockedCountUpdateManager } from \"./blockedCountUpdateManager\";\nexport class GoogleScriptService {\n    get blockedCount() {\n        return this._blockedCount;\n    }\n    get resultsAreHidden() {\n        return this._resultsAreHidden;\n    }\n    setBlockedElementsVisibility(value) {\n        this._resultsAreHidden = value;\n        this.updateBlockedElementsVisibility();\n    }\n    constructor(blockedUrlsDict, settings, lifeTimeBlocks) {\n        this._blockedCount = 0;\n        this._resultsAreHidden = false;\n        this.blockedUrlsDict = blockedUrlsDict;\n        this.settings = settings;\n        this.addDocumentHead();\n        this.addEventListeners();\n        this.updateManager = new BlockedCountUpdateManager(blockedUrlsDict, lifeTimeBlocks, this.updatedBlockedCallback.bind(this));\n        // Initialize the searchContainer for if it cant be found\n        this.searchResultsContainer = document.body;\n    }\n    // Return a promise that resolves when the search element is found\n    getSearchElement() {\n        return new Promise((resolve) => {\n            new MutationObserver((_, obs) => {\n                const searchElement = document.querySelector(\"#search\");\n                if (searchElement) {\n                    this.searchResultsContainer = searchElement;\n                    obs.disconnect();\n                    resolve();\n                }\n            }).observe(document.body, {\n                childList: true,\n                subtree: true,\n            });\n        });\n    }\n    addEventListeners() {\n        document.addEventListener(\"DOMContentLoaded\", () => {\n            addTopOfPage(() => this.resultsAreHidden, (value) => this.setBlockedElementsVisibility(value), this.blockedCount, this.settings.extensionIsOn);\n        });\n    }\n    // Adds extra styles to the head of the document\n    addDocumentHead() {\n        const style = document.createElement(\"style\");\n        style.id = \"Site Blocker Custom Styles\";\n        style.textContent = `\r\n        /* Display Styles */\r\n        [card-show=\"false\"] { display: none !important; }\r\n        /* Card Color Styles */\r\n        [card-relevant=\"true\"] {opacity: 0.3 !important}\r\n      `;\n        document.head.appendChild(style);\n    }\n    incrementBlockCount(userPattern, searchCategory) {\n        this._blockedCount++;\n        this.updateManager.incrementCount(userPattern, searchCategory);\n    }\n    updatedBlockedCallback(updatedDataUrlBlocked) {\n        this.blockedUrlsDict.blockedUrlData = updatedDataUrlBlocked;\n        chrome.runtime.sendMessage({\n            type: \"updateBadge\",\n            count: this._blockedCount,\n        });\n    }\n    // Mark element as blocked and also increment the block count\n    markElementAsBlocked(element) {\n        updateBlockedCount(this.blockedCount);\n        element.setAttribute(\"card-show\", this.resultsAreHidden.toString());\n        element.setAttribute(\"card-relevant\", \"true\");\n    }\n    // Users can toggle if blocked content is hidden or visible\n    updateBlockedElementsVisibility() {\n        const hiddenElements = document.querySelectorAll(\"[card-show]\");\n        hiddenElements.forEach((element) => {\n            if (element instanceof HTMLElement) {\n                element.setAttribute(\"card-show\", this._resultsAreHidden.toString());\n            }\n        });\n    }\n    shouldUrlBeBlocked(googleSearchUrl, searchCategory, origin) {\n        const url = new URL(googleSearchUrl);\n        for (const pattern of Object.keys(this.blockedUrlsDict.blockedUrlData)) {\n            // Here we check if the pattern is an URL and if it matches the current checked URL\n            if (isPatternUrl(url, googleSearchUrl, pattern)) {\n                console.log(`Blocked URL: ${googleSearchUrl} url pattern: ${pattern} from ${origin}`);\n                this.incrementBlockCount(pattern, searchCategory);\n                return true;\n            }\n            // Here we check if the pattern is a matched Pattern and if it matches the current checked URL\n            if (isPatternWildcard(googleSearchUrl, pattern)) {\n                this.incrementBlockCount(pattern, searchCategory);\n                console.log(`Blocked URL: ${url} matched pattern: ${pattern} from ${origin}`);\n                return true;\n            }\n        }\n        return false;\n    }\n    processSearchResultsForBlocking(queryString, containerToSearchIn, blockInvisibleElements, searchCategory) {\n        const searchResults = containerToSearchIn.querySelectorAll(queryString);\n        if (searchResults.length > 0) {\n            console.log(\"search Results \", searchResults);\n        }\n        searchResults === null || searchResults === void 0 ? void 0 : searchResults.forEach((searchElement) => {\n            searchElement.setAttribute(\"data-processed\", \"true\");\n            if (this.checkLinksForBlockedUrls(searchElement, blockInvisibleElements, searchCategory, `regular`) ||\n                this.checkCitesForBlockedUrls(searchElement, blockInvisibleElements, searchCategory, `regular`)) {\n                this.markElementAsBlocked(searchElement);\n            }\n        });\n    }\n    isElementVisible(element) {\n        return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);\n    }\n    checkLinksForBlockedUrls(searchElement, blockInvisibleElements, searchCategory, origin) {\n        const links = searchElement.querySelectorAll(\"a\");\n        for (const link of links) {\n            if (blockInvisibleElements || this.isElementVisible(link)) {\n                if (link.href && this.shouldUrlBeBlocked(link.href, searchCategory, origin)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    checkCitesForBlockedUrls(searchElement, blockInvisibleElements, searchCategory, origin) {\n        var _a;\n        const cites = searchElement.querySelectorAll(\"cite\");\n        for (const cite of cites) {\n            let url = (_a = cite.textContent) === null || _a === void 0 ? void 0 : _a.split(\" \")[0]; // Get first text in cite (it concatenates all descendants)\n            if (url) {\n                // Add 'https://' if the URL doesn't start with 'http://' or 'https://'\n                if (!/^https?:\\/\\//i.test(url)) {\n                    url = \"https://\" + url;\n                }\n                if (blockInvisibleElements || this.isElementVisible(cite)) {\n                    if (this.shouldUrlBeBlocked(url, searchCategory, origin)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    // Block invis elements as well as sometimes they load in the \"all image\" section before the user sees them\n    processImagesForBlocking() {\n        if (this.settings.blockImage) {\n            const queryString = \".ivg-i:not([data-processed])\";\n            this.processSearchResultsForBlocking(queryString, this.searchResultsContainer, true, \"i\");\n        }\n    }\n    // Blocks the top scrollbar of adds at the top of the product / regular / image page\n    processTopAddsForBlocking() {\n        if (this.settings.blockAds) {\n            const queryString = \".mnr-c.pla-unit:not([data-processed])\";\n            this.processSearchResultsForBlocking(queryString, document.body, true, \"i\");\n        }\n    }\n    // hard to do since there are no links as the product page just opens a popup instead of a website\n    // processProductsForBlocking() {\n    //   const queryString: string = \".LrTUQ.LPpDAd:not([data-processed])\"\n    //   this.processSearchResultsForBlocking(queryString, document.body, true, \"i\")\n    // }\n    processNewsForBlocking() {\n        if (this.settings.blockNews) {\n            const queryString = \".SoaBEf:not([data-processed])\";\n            this.processSearchResultsForBlocking(queryString, this.searchResultsContainer, false, \"n\");\n        }\n    }\n    processVideosForBlocking() {\n        if (this.settings.blockVideo) {\n            const queryString = \".g:not([data-processed])\";\n            this.processSearchResultsForBlocking(queryString, this.searchResultsContainer, false, \"v\");\n        }\n    }\n    processRegularForBlocking() {\n        if (this.settings.blockWeb) {\n            const queryString = \".g:not([data-processed]):not([data-initq]:not(.ivg-i):not(.related-question-pair)\";\n            this.processSearchResultsForBlocking(queryString, this.searchResultsContainer, false, \"w\");\n        }\n    }\n    processRecipes() {\n        if (this.settings.blockRecipe) {\n            const queryString = \".F6H0Gb.h2UtUe:not([data-processed])\";\n            this.processSearchResultsForBlocking(queryString, this.searchResultsContainer, false, \"w\");\n        }\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GoogleScriptService } from \"./contentScript\";\nexport default function googleSearchImages(_a) {\n    return __awaiter(this, arguments, void 0, function* ({ settings, urlsDict, lifeTimeBlocks, }) {\n        const ContentScript = new GoogleScriptService(urlsDict, settings, lifeTimeBlocks);\n        // We check extension is on here so GoogleScriptService still loads custom top of page element that shows the extension is turned off\n        if (!settings.extensionIsOn) {\n            return;\n        }\n        yield ContentScript.getSearchElement();\n        ContentScript.processImagesForBlocking();\n        ContentScript.processTopAddsForBlocking();\n        if (ContentScript.searchResultsContainer) {\n            new MutationObserver(() => {\n                ContentScript.processImagesForBlocking();\n                ContentScript.processTopAddsForBlocking();\n            }).observe(ContentScript.searchResultsContainer, {\n                childList: true,\n                subtree: true,\n            });\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GoogleScriptService } from \"./contentScript\";\nexport default function googleSearchNews(_a) {\n    return __awaiter(this, arguments, void 0, function* ({ settings, urlsDict, lifeTimeBlocks, }) {\n        const ContentScript = new GoogleScriptService(urlsDict, settings, lifeTimeBlocks);\n        // We check extension is on here so GoogleScriptService still loads custom top of page element that shows the extension is turned off\n        if (!settings.extensionIsOn) {\n            return;\n        }\n        yield ContentScript.getSearchElement();\n        ContentScript.processNewsForBlocking();\n        if (ContentScript.searchResultsContainer) {\n            new MutationObserver(() => {\n                ContentScript.processNewsForBlocking();\n            }).observe(ContentScript.searchResultsContainer, {\n                childList: true,\n                subtree: true,\n            });\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GoogleScriptService } from \"./contentScript\";\nexport default function googleSearchRegular(_a) {\n    return __awaiter(this, arguments, void 0, function* ({ settings, urlsDict, lifeTimeBlocks, }) {\n        const ContentScript = new GoogleScriptService(urlsDict, settings, lifeTimeBlocks);\n        // We check extension is on here so GoogleScriptService still loads custom top of page element that shows the extension is turned off\n        if (!settings.extensionIsOn) {\n            return;\n        }\n        yield ContentScript.getSearchElement();\n        ContentScript.processRegularForBlocking();\n        ContentScript.processImagesForBlocking();\n        ContentScript.processTopAddsForBlocking();\n        ContentScript.processRecipes();\n        if (ContentScript.searchResultsContainer) {\n            new MutationObserver(() => {\n                ContentScript.processRegularForBlocking();\n                ContentScript.processImagesForBlocking();\n                ContentScript.processTopAddsForBlocking();\n                setTimeout(() => processRelatedQuestionsForBlocking(), 500); //TODO fix need for 500 timeout\n                ContentScript.processRecipes();\n            }).observe(ContentScript.searchResultsContainer, {\n                childList: true,\n                subtree: true,\n            });\n        }\n        function processRelatedQuestionsForBlocking() {\n            var _a;\n            if (!settings.blockWeb) {\n                return;\n            }\n            const moreToAskSections = (_a = ContentScript.searchResultsContainer) === null || _a === void 0 ? void 0 : _a.querySelectorAll(\"[data-initq]\");\n            moreToAskSections === null || moreToAskSections === void 0 ? void 0 : moreToAskSections.forEach((askSection) => {\n                const relatedQuestions = askSection.querySelectorAll(\".related-question-pair:not([data-processed])\");\n                relatedQuestions.forEach((relatedQuestion) => {\n                    relatedQuestion.setAttribute(\"data-processed\", \"true\");\n                    if (ContentScript.checkLinksForBlockedUrls(relatedQuestion, true, \"w\", \"related Q\") ||\n                        ContentScript.checkCitesForBlockedUrls(relatedQuestion, true, \"w\", \"related Q\")) {\n                        console.log(\"block \", relatedQuestion);\n                        ContentScript.markElementAsBlocked(relatedQuestion);\n                    }\n                });\n            });\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GoogleScriptService } from \"./contentScript\";\nexport default function googleSearchVideos(_a) {\n    return __awaiter(this, arguments, void 0, function* ({ settings, urlsDict, lifeTimeBlocks, }) {\n        const ContentScript = new GoogleScriptService(urlsDict, settings, lifeTimeBlocks);\n        // We check extension is on here so GoogleScriptService still loads custom top of page element that shows the extension is turned off\n        if (!settings.extensionIsOn) {\n            return;\n        }\n        yield ContentScript.getSearchElement();\n        ContentScript.processVideosForBlocking();\n        new MutationObserver(() => {\n            ContentScript.processVideosForBlocking();\n        }).observe(ContentScript.searchResultsContainer, {\n            childList: true,\n            subtree: true,\n        });\n    });\n}\n","// When we enter a blocked site via popup or option page do the following:\n// if \"www.\" then replace it with \"*://*.\"\n// if doesnt start with http and is not a valid match pattern than add \"*://*.\"\nexport function transformUserInputToValidURL(input) {\n    if (!input)\n        return input;\n    const matchPattern = \"*://*.\";\n    if (input.startsWith(\"www.\")) {\n        input = input.replace(\"www.\", \"\");\n        return matchPattern + input;\n    }\n    else {\n        if (!input.startsWith(\"http\") && !isValidMatchPattern(input)) {\n            return matchPattern + input;\n        }\n    }\n    return input;\n}\n// valid urls should be:\n// https://www.reddit.com\n// https://.reddit.com\n// www.reddit.com\n// reddit.com\n// http://www.reddit.com\n// http://reddit.com\nexport function isValidUrl(input) {\n    const urlRegex = /^(www\\.[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+(?:\\/.*)?|[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+(?:\\/.*)?|https:\\/\\/www\\.[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+(?:\\/.*)?|https?:\\/\\/[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+(?:\\/.*)?|file:\\/\\/\\/.*)$/;\n    return urlRegex.test(input);\n}\nexport function isValidMatchPattern(input) {\n    const matchPatternRegex = /^(?:(?:\\*|https?|ftp):\\/\\/(?:\\*|(?:\\*\\.)?[^/*]+)(?:\\/.*)?|\\*:\\/\\/.*)$/;\n    return matchPatternRegex.test(input);\n}\nexport function stringToUrl(input) {\n    input = input.replace(/^\\.|\\.$/, \"\"); // If input starts or ends with . remove it\n    if (!isValidUrl(input)) {\n        return input.startsWith(\"http\") && !isValidMatchPattern(input) ? input : `*://*.${input}.com`;\n    }\n    else {\n        return `${input}`;\n    }\n}\nexport function stringToMatchPattern(input) {\n    input = input.replace(/^(https?:\\/\\/)?(www\\.)?/, \"\");\n    const parts = input.split(\".\");\n    if (parts.length > 1) {\n        // If it's a domain-like string, create a match pattern\n        return `*://*.${parts[0]}.*`;\n    }\n    else {\n        // If it's just text, treat it as a domain name\n        return `*://*.${input}.*`;\n    }\n}\nfunction removeTrailingSlash(s) {\n    return s.endsWith(\"/\") ? s.slice(0, -1) : s;\n}\nexport function isPatternUrl(url, urlString, pattern) {\n    try {\n        if (!pattern) {\n            return false;\n        }\n        pattern = removeTrailingSlash(pattern.toLowerCase());\n        const patternVariations = [\n            pattern,\n            `www.${pattern}`,\n            `https://${pattern}`,\n            `https://www.${pattern}`,\n            `http://${pattern}`,\n            `http://www.${pattern}`,\n        ];\n        const comparisons = [\n            urlString,\n            url.origin.toLowerCase(),\n            url.host.toLowerCase(),\n            url.hostname.toLowerCase(),\n            removeTrailingSlash(url.href.toLowerCase()),\n        ];\n        for (const comp of comparisons) {\n            for (const variation of patternVariations) {\n                if (comp === variation) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    catch (error) {\n        console.error(`Invalid URL`);\n        return false;\n    }\n}\nexport function isPatternWildcard(urlString, pattern) {\n    urlString = urlString.toLowerCase();\n    pattern = pattern.toLowerCase();\n    const escapedPattern = pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\").replace(/\\\\\\*/g, \".*\");\n    const regex = new RegExp(`^${escapedPattern}(/.*)?$`);\n    return regex.test(urlString);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport googleSearchRegular from \"./googleRegular\";\nimport googleSearchImages from \"./googleImages\";\nimport googleSearchVideos from \"./googleVideos\";\nimport googleSearchNews from \"./googleNews\";\nfunction initializeContentScript() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const settings = yield isExtensionOn();\n        const urlsDict = yield getBlockedUrl();\n        const lifeTimeBlocks = yield getLifeTimeBlockedUrl();\n        if (!urlsDict.blockedUrlData) {\n            return;\n        }\n        callContentScript({ settings, urlsDict, lifeTimeBlocks });\n    });\n}\nfunction callContentScript(googleContentScriptProps) {\n    var _a, _b;\n    const url = new URL(window.location.href);\n    const urlParameters = url.searchParams;\n    const tbm = (_a = urlParameters.get(\"tbm\")) !== null && _a !== void 0 ? _a : \"\";\n    const udm = (_b = urlParameters.get(\"udm\")) !== null && _b !== void 0 ? _b : \"\";\n    if (tbm.includes(\"bks\")) {\n        // Not implemented\n    }\n    else if (tbm.includes(\"vid\")) {\n        googleSearchVideos(googleContentScriptProps);\n    }\n    else if (tbm.includes(\"nws\")) {\n        googleSearchNews(googleContentScriptProps);\n    }\n    else if (udm.includes(\"2\")) {\n        googleSearchImages(googleContentScriptProps);\n    }\n    else {\n        googleSearchRegular(googleContentScriptProps);\n    }\n}\nfunction isExtensionOn() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve) => {\n            chrome.storage.local.get([\n                \"extensionIsOn\",\n                \"blockAds\",\n                \"blockImage\",\n                \"blockNews\",\n                \"blockRecipe\",\n                \"blockVideo\",\n                \"blockWeb\",\n            ], (result) => {\n                var _a, _b, _c, _d, _e, _f, _g;\n                resolve({\n                    extensionIsOn: (_a = result.extensionIsOn) !== null && _a !== void 0 ? _a : true,\n                    blockAds: (_b = result.blockAds) !== null && _b !== void 0 ? _b : false,\n                    blockImage: (_c = result.blockImage) !== null && _c !== void 0 ? _c : false,\n                    blockNews: (_d = result.blockNews) !== null && _d !== void 0 ? _d : false,\n                    blockRecipe: (_e = result.blockRecipe) !== null && _e !== void 0 ? _e : false,\n                    blockVideo: (_f = result.blockVideo) !== null && _f !== void 0 ? _f : false,\n                    blockWeb: (_g = result.blockWeb) !== null && _g !== void 0 ? _g : false,\n                });\n            });\n        });\n    });\n}\nfunction getBlockedUrl() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const result = yield chrome.storage.local.get(\"blockedUrlData\");\n        return { blockedUrlData: result.blockedUrlData || {} };\n    });\n}\nfunction getLifeTimeBlockedUrl() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const result = yield chrome.storage.local.get(\"lifetimeTotalBlocks\");\n        return result.lifetimeTotalBlocks;\n    });\n}\ninitializeContentScript();\n"],"names":[],"sourceRoot":""}